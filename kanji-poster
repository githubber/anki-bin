#!/usr/bin/env perl
use 5.14.0;
use warnings;
use utf8::all;
use Encode 'decode_utf8', 'encode_utf8';
use DBI;
use JSON;
use autodie;
use Getopt::Whatever;
use File::Slurp 'slurp', 'write_file';
use Lingua::JA::Heisig 'kanji';

my $status_file = "$ENV{HOME}/.kanji-poster";
my %old_kanji_status;
%old_kanji_status = %{ from_json(slurp($status_file, err_mode => 'quiet') || '{}', { utf8 => 1 } ) };

my $dbh = DBI->connect("dbi:SQLite:dbname=$ENV{ANKI_DECK}");
my $kanji_sth = $dbh->prepare("
    select kanji.value, reading.value
    from fields as kanji
        join fieldModels as kanjiField on (kanji.fieldModelId = kanjiField.id)
        join fields as reading on (kanji.factId = reading.factId)
        join fieldModels as readingField on (reading.fieldModelId = readingField.id)
        join cards on (cards.factId = kanji.factId)
        join cardModels on (cards.cardModelId = cardModels.id)
        join models on (kanjiField.modelId = models.id)
    where
        kanjiField.name = '漢字'
        and readingField.name = '読み'
        and models.name = 'Heisig 漢字'
        and cardModels.name = '書け'
        order by cards.created asc
;");

my $sentence_sth = $dbh->prepare("
    select sentence.value
    from fields as sentence
        join fieldModels on (fieldModels.id = sentence.fieldModelId)
        join models on (fieldModels.modelId = models.id)
        join cards on (cards.factId = sentence.factId)
    where
        fieldModels.name = '日本語'
        and models.name = '文'
        and cards.type>0
;");

$kanji_sth->execute;

my %kanji_status;
my @kanji;
my $has_changes = 0;

while (my ($kanji, $reading) = map { decode_utf8($_) } $kanji_sth->fetchrow_array) {
    my $status = 'heisig';

    $status = 'reading' if length $reading;

    push @kanji, $kanji;

    $kanji_status{$kanji} = $status;
}

$sentence_sth->execute;

while (my ($sentence) = map { decode_utf8($_) } $sentence_sth->fetchrow_array) {
    for my $kanji ($sentence =~ /(\p{Han})/g) {
        $kanji_status{$kanji} = 'sentence'
            if ($kanji_status{$kanji}||'heisig') eq 'heisig';
    }
}

my $i = 0;
for my $kanji (@kanji) {
    print_kanji($kanji);
}

if (@kanji < 2048) {
    print "\e[1;31m";
    for ($i+1 .. $i+32) {
        print "ー";
        print "\n" if $_ % 32 == 0;
    }
}

for my $kanji ((kanji)[@kanji..2041]) {
    print_kanji($kanji);
}

print "\n";

my $write_file = $ARGV{commit};
if (!exists($ARGV{commit}) && $has_changes) {
    local $| = 1;
    print "Do you want to commit? [yN] ";
    my $commit = <>;
    if ($commit =~ /^y/i) {
        $write_file = 1;
    }
}

if ($write_file) {
    write_file $status_file, encode_utf8 to_json(\%kanji_status);
    say "Committed.";
}

sub print_kanji {
    my $kanji = shift;
    my $status = $kanji_status{$kanji} || '';
    my $old_status = $old_kanji_status{$kanji} || '';

    if (!$ARGV{full} && $status eq $old_status) {
        print "\e[1;37m";
        goto PRINT_KANJI;
    }

    $has_changes = 1;

    given ($status) {
        when ('sentence') { print "\e[1;32m" }
        when ('reading')  { print "\e[1;31m" }
    }

    PRINT_KANJI:

    print $kanji;

    print "\e[m";

    if (++$i % 32 == 0) {
        if ($ARGV{gradual}) {
            scalar <>;
            print "\e[2J";
        }
        print "\n";
    }
}
